// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: island_management.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addResourcesToPort = `-- name: AddResourcesToPort :exec
UPDATE resources 
SET 
    wood = wood + $2,
    iron = iron + $3,
    rum = rum + $4,
    sugar = sugar + $5,
    tobacco = tobacco + $6,
    cotton = cotton + $7,
    coffee = coffee + $8,
    grain = grain + $9,
    gold = gold + $10,
    silver = silver + $11,
    updated_at = NOW()
WHERE port_id = $1
`

type AddResourcesToPortParams struct {
	PortID  int32
	Wood    int32
	Iron    int32
	Rum     int32
	Sugar   int32
	Tobacco int32
	Cotton  int32
	Coffee  int32
	Grain   int32
	Gold    int32
	Silver  int32
}

func (q *Queries) AddResourcesToPort(ctx context.Context, arg AddResourcesToPortParams) error {
	_, err := q.db.Exec(ctx, addResourcesToPort,
		arg.PortID,
		arg.Wood,
		arg.Iron,
		arg.Rum,
		arg.Sugar,
		arg.Tobacco,
		arg.Cotton,
		arg.Coffee,
		arg.Grain,
		arg.Gold,
		arg.Silver,
	)
	return err
}

const checkResourceAvailability = `-- name: CheckResourceAvailability :one
SELECT 
    (wood >= $2) as has_wood,
    (iron >= $3) as has_iron,
    (gold >= $4) as has_gold
FROM resources 
WHERE port_id = $1
`

type CheckResourceAvailabilityParams struct {
	PortID int32
	Wood   int32
	Iron   int32
	Gold   int32
}

type CheckResourceAvailabilityRow struct {
	HasWood bool
	HasIron bool
	HasGold bool
}

func (q *Queries) CheckResourceAvailability(ctx context.Context, arg CheckResourceAvailabilityParams) (CheckResourceAvailabilityRow, error) {
	row := q.db.QueryRow(ctx, checkResourceAvailability,
		arg.PortID,
		arg.Wood,
		arg.Iron,
		arg.Gold,
	)
	var i CheckResourceAvailabilityRow
	err := row.Scan(&i.HasWood, &i.HasIron, &i.HasGold)
	return i, err
}

const completeBuildingConstruction = `-- name: CompleteBuildingConstruction :exec
UPDATE buildings 
SET under_construction = FALSE, 
    construction_complete_at = NULL,
    last_production_at = NOW()
WHERE id = $1
`

func (q *Queries) CompleteBuildingConstruction(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, completeBuildingConstruction, id)
	return err
}

const consumeResourcesFromPort = `-- name: ConsumeResourcesFromPort :exec
UPDATE resources 
SET 
    wood = GREATEST(0, wood - $2),
    iron = GREATEST(0, iron - $3),
    rum = GREATEST(0, rum - $4),
    sugar = GREATEST(0, sugar - $5),
    tobacco = GREATEST(0, tobacco - $6),
    cotton = GREATEST(0, cotton - $7),
    coffee = GREATEST(0, coffee - $8),
    grain = GREATEST(0, grain - $9),
    gold = GREATEST(0, gold - $10),
    silver = GREATEST(0, silver - $11),
    updated_at = NOW()
WHERE port_id = $1
`

type ConsumeResourcesFromPortParams struct {
	PortID  int32
	Wood    int32
	Iron    int32
	Rum     int32
	Sugar   int32
	Tobacco int32
	Cotton  int32
	Coffee  int32
	Grain   int32
	Gold    int32
	Silver  int32
}

func (q *Queries) ConsumeResourcesFromPort(ctx context.Context, arg ConsumeResourcesFromPortParams) error {
	_, err := q.db.Exec(ctx, consumeResourcesFromPort,
		arg.PortID,
		arg.Wood,
		arg.Iron,
		arg.Rum,
		arg.Sugar,
		arg.Tobacco,
		arg.Cotton,
		arg.Coffee,
		arg.Grain,
		arg.Gold,
		arg.Silver,
	)
	return err
}

const createBuildingConstruction = `-- name: CreateBuildingConstruction :one
INSERT INTO buildings (port_id, type, under_construction, construction_complete_at)
VALUES ($1, $2, TRUE, $3)
RETURNING id, port_id, type, level, created_at, under_construction, construction_complete_at, last_production_at
`

type CreateBuildingConstructionParams struct {
	PortID                 int32
	Type                   string
	ConstructionCompleteAt pgtype.Timestamptz
}

func (q *Queries) CreateBuildingConstruction(ctx context.Context, arg CreateBuildingConstructionParams) (Building, error) {
	row := q.db.QueryRow(ctx, createBuildingConstruction, arg.PortID, arg.Type, arg.ConstructionCompleteAt)
	var i Building
	err := row.Scan(
		&i.ID,
		&i.PortID,
		&i.Type,
		&i.Level,
		&i.CreatedAt,
		&i.UnderConstruction,
		&i.ConstructionCompleteAt,
		&i.LastProductionAt,
	)
	return i, err
}

const getAllBuildingTypes = `-- name: GetAllBuildingTypes :many
SELECT id, type_name, display_name, description, category, max_level, base_cost_wood, base_cost_iron, base_cost_gold, base_build_time, created_at FROM building_types ORDER BY category, type_name
`

// Building Types Queries
func (q *Queries) GetAllBuildingTypes(ctx context.Context) ([]BuildingType, error) {
	rows, err := q.db.Query(ctx, getAllBuildingTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BuildingType
	for rows.Next() {
		var i BuildingType
		if err := rows.Scan(
			&i.ID,
			&i.TypeName,
			&i.DisplayName,
			&i.Description,
			&i.Category,
			&i.MaxLevel,
			&i.BaseCostWood,
			&i.BaseCostIron,
			&i.BaseCostGold,
			&i.BaseBuildTime,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProductionForBuildingType = `-- name: GetAllProductionForBuildingType :many
SELECT bp.level, bp.resource_type, bp.production_rate
FROM building_production bp
JOIN building_types bt ON bp.building_type_id = bt.id
WHERE bt.type_name = $1
ORDER BY bp.level, bp.resource_type
`

type GetAllProductionForBuildingTypeRow struct {
	Level          int32
	ResourceType   string
	ProductionRate int32
}

func (q *Queries) GetAllProductionForBuildingType(ctx context.Context, typeName string) ([]GetAllProductionForBuildingTypeRow, error) {
	rows, err := q.db.Query(ctx, getAllProductionForBuildingType, typeName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllProductionForBuildingTypeRow
	for rows.Next() {
		var i GetAllProductionForBuildingTypeRow
		if err := rows.Scan(&i.Level, &i.ResourceType, &i.ProductionRate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBuildingTypeByName = `-- name: GetBuildingTypeByName :one
SELECT id, type_name, display_name, description, category, max_level, base_cost_wood, base_cost_iron, base_cost_gold, base_build_time, created_at FROM building_types WHERE type_name = $1
`

func (q *Queries) GetBuildingTypeByName(ctx context.Context, typeName string) (BuildingType, error) {
	row := q.db.QueryRow(ctx, getBuildingTypeByName, typeName)
	var i BuildingType
	err := row.Scan(
		&i.ID,
		&i.TypeName,
		&i.DisplayName,
		&i.Description,
		&i.Category,
		&i.MaxLevel,
		&i.BaseCostWood,
		&i.BaseCostIron,
		&i.BaseCostGold,
		&i.BaseBuildTime,
		&i.CreatedAt,
	)
	return i, err
}

const getBuildingTypesByCategory = `-- name: GetBuildingTypesByCategory :many
SELECT id, type_name, display_name, description, category, max_level, base_cost_wood, base_cost_iron, base_cost_gold, base_build_time, created_at FROM building_types WHERE category = $1 ORDER BY type_name
`

func (q *Queries) GetBuildingTypesByCategory(ctx context.Context, category string) ([]BuildingType, error) {
	rows, err := q.db.Query(ctx, getBuildingTypesByCategory, category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BuildingType
	for rows.Next() {
		var i BuildingType
		if err := rows.Scan(
			&i.ID,
			&i.TypeName,
			&i.DisplayName,
			&i.Description,
			&i.Category,
			&i.MaxLevel,
			&i.BaseCostWood,
			&i.BaseCostIron,
			&i.BaseCostGold,
			&i.BaseBuildTime,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBuildingsReadyForProduction = `-- name: GetBuildingsReadyForProduction :many
SELECT 
    b.id,
    b.port_id,
    b.type,
    b.level,
    b.last_production_at
FROM buildings b
WHERE b.under_construction = FALSE 
AND (b.last_production_at IS NULL OR b.last_production_at < $1)
`

type GetBuildingsReadyForProductionRow struct {
	ID               int32
	PortID           int32
	Type             string
	Level            int32
	LastProductionAt pgtype.Timestamptz
}

func (q *Queries) GetBuildingsReadyForProduction(ctx context.Context, lastProductionAt pgtype.Timestamptz) ([]GetBuildingsReadyForProductionRow, error) {
	rows, err := q.db.Query(ctx, getBuildingsReadyForProduction, lastProductionAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBuildingsReadyForProductionRow
	for rows.Next() {
		var i GetBuildingsReadyForProductionRow
		if err := rows.Scan(
			&i.ID,
			&i.PortID,
			&i.Type,
			&i.Level,
			&i.LastProductionAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBuildingsUnderConstruction = `-- name: GetBuildingsUnderConstruction :many
SELECT b.id, b.port_id, b.type, b.level, b.created_at, b.under_construction, b.construction_complete_at, b.last_production_at, bt.display_name, bt.base_build_time
FROM buildings b
JOIN building_types bt ON b.type = bt.type_name
WHERE b.under_construction = TRUE 
AND b.construction_complete_at <= NOW()
`

type GetBuildingsUnderConstructionRow struct {
	ID                     int32
	PortID                 int32
	Type                   string
	Level                  int32
	CreatedAt              pgtype.Timestamptz
	UnderConstruction      bool
	ConstructionCompleteAt pgtype.Timestamptz
	LastProductionAt       pgtype.Timestamptz
	DisplayName            string
	BaseBuildTime          int32
}

func (q *Queries) GetBuildingsUnderConstruction(ctx context.Context) ([]GetBuildingsUnderConstructionRow, error) {
	rows, err := q.db.Query(ctx, getBuildingsUnderConstruction)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBuildingsUnderConstructionRow
	for rows.Next() {
		var i GetBuildingsUnderConstructionRow
		if err := rows.Scan(
			&i.ID,
			&i.PortID,
			&i.Type,
			&i.Level,
			&i.CreatedAt,
			&i.UnderConstruction,
			&i.ConstructionCompleteAt,
			&i.LastProductionAt,
			&i.DisplayName,
			&i.BaseBuildTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPortBuildings = `-- name: GetPortBuildings :many
SELECT 
    b.id,
    b.port_id,
    b.type,
    b.level,
    b.under_construction,
    b.construction_complete_at,
    b.last_production_at,
    b.created_at,
    bt.display_name,
    bt.description,
    bt.category,
    bt.max_level
FROM buildings b
JOIN building_types bt ON b.type = bt.type_name
WHERE b.port_id = $1
ORDER BY bt.category, b.type
`

type GetPortBuildingsRow struct {
	ID                     int32
	PortID                 int32
	Type                   string
	Level                  int32
	UnderConstruction      bool
	ConstructionCompleteAt pgtype.Timestamptz
	LastProductionAt       pgtype.Timestamptz
	CreatedAt              pgtype.Timestamptz
	DisplayName            string
	Description            pgtype.Text
	Category               string
	MaxLevel               int32
}

func (q *Queries) GetPortBuildings(ctx context.Context, portID int32) ([]GetPortBuildingsRow, error) {
	rows, err := q.db.Query(ctx, getPortBuildings, portID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPortBuildingsRow
	for rows.Next() {
		var i GetPortBuildingsRow
		if err := rows.Scan(
			&i.ID,
			&i.PortID,
			&i.Type,
			&i.Level,
			&i.UnderConstruction,
			&i.ConstructionCompleteAt,
			&i.LastProductionAt,
			&i.CreatedAt,
			&i.DisplayName,
			&i.Description,
			&i.Category,
			&i.MaxLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPortWithResources = `-- name: GetPortWithResources :one
SELECT 
    p.id as port_id,
    p.name as port_name,
    p.player_id,
    p.x,
    p.y,
    p.created_at as port_created_at,
    r.wood,
    r.iron,
    r.rum,
    r.sugar,
    r.tobacco,
    r.cotton,
    r.coffee,
    r.grain,
    r.gold,
    r.silver,
    r.updated_at as resources_updated_at
FROM ports p
LEFT JOIN resources r ON p.id = r.port_id
WHERE p.id = $1
`

type GetPortWithResourcesRow struct {
	PortID             int32
	PortName           string
	PlayerID           int32
	X                  int32
	Y                  int32
	PortCreatedAt      pgtype.Timestamptz
	Wood               pgtype.Int4
	Iron               pgtype.Int4
	Rum                pgtype.Int4
	Sugar              pgtype.Int4
	Tobacco            pgtype.Int4
	Cotton             pgtype.Int4
	Coffee             pgtype.Int4
	Grain              pgtype.Int4
	Gold               pgtype.Int4
	Silver             pgtype.Int4
	ResourcesUpdatedAt pgtype.Timestamptz
}

// Island/Port Management Queries
func (q *Queries) GetPortWithResources(ctx context.Context, id int32) (GetPortWithResourcesRow, error) {
	row := q.db.QueryRow(ctx, getPortWithResources, id)
	var i GetPortWithResourcesRow
	err := row.Scan(
		&i.PortID,
		&i.PortName,
		&i.PlayerID,
		&i.X,
		&i.Y,
		&i.PortCreatedAt,
		&i.Wood,
		&i.Iron,
		&i.Rum,
		&i.Sugar,
		&i.Tobacco,
		&i.Cotton,
		&i.Coffee,
		&i.Grain,
		&i.Gold,
		&i.Silver,
		&i.ResourcesUpdatedAt,
	)
	return i, err
}

const getProductionRatesForBuilding = `-- name: GetProductionRatesForBuilding :many
SELECT bp.resource_type, bp.production_rate 
FROM building_production bp
JOIN building_types bt ON bp.building_type_id = bt.id
WHERE bt.type_name = $1 AND bp.level = $2
`

type GetProductionRatesForBuildingParams struct {
	TypeName string
	Level    int32
}

type GetProductionRatesForBuildingRow struct {
	ResourceType   string
	ProductionRate int32
}

// Building Production Queries
func (q *Queries) GetProductionRatesForBuilding(ctx context.Context, arg GetProductionRatesForBuildingParams) ([]GetProductionRatesForBuildingRow, error) {
	rows, err := q.db.Query(ctx, getProductionRatesForBuilding, arg.TypeName, arg.Level)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductionRatesForBuildingRow
	for rows.Next() {
		var i GetProductionRatesForBuildingRow
		if err := rows.Scan(&i.ResourceType, &i.ProductionRate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const initializePortResources = `-- name: InitializePortResources :exec
INSERT INTO resources (port_id) 
VALUES ($1)
ON CONFLICT (port_id) DO NOTHING
`

// Resource Management Queries
func (q *Queries) InitializePortResources(ctx context.Context, portID int32) error {
	_, err := q.db.Exec(ctx, initializePortResources, portID)
	return err
}

const updateBuildingLastProduction = `-- name: UpdateBuildingLastProduction :exec
UPDATE buildings 
SET last_production_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateBuildingLastProduction(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, updateBuildingLastProduction, id)
	return err
}

const upgradeBuilding = `-- name: UpgradeBuilding :exec
UPDATE buildings 
SET level = level + 1,
    under_construction = TRUE,
    construction_complete_at = $2
WHERE buildings.id = $1 AND buildings.level < (
    SELECT bt.max_level FROM building_types bt WHERE bt.type_name = (
        SELECT b.type FROM buildings b WHERE b.id = $1
    )
)
`

type UpgradeBuildingParams struct {
	ID                     int32
	ConstructionCompleteAt pgtype.Timestamptz
}

func (q *Queries) UpgradeBuilding(ctx context.Context, arg UpgradeBuildingParams) error {
	_, err := q.db.Exec(ctx, upgradeBuilding, arg.ID, arg.ConstructionCompleteAt)
	return err
}
